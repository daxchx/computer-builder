
# Computer Builder

thumbnail.gif

## 説明

このアプリケーションではパーツを選んで「仮想のコンピュータ」を組み立て、その性能を評価し、比較することが可能です。

コンピュータを構成するパーツは全部で4種類。
- cpu
- gpu
- memory
- storage

各パーツの選択時には、ブランド、モデル、ストレージなどを入力します。
ブランドにはそのブランドが持っている情報をソートしてモデルに表示します。

## 使い方

1. URL にアクセス
2. CPU のブランドとモデルを選択
3. GPU のブランドとモデルを選択
4. Memory Card の数とブランドとモデルを選択
5. Storage のタイプとストレージとブランドとモデルを選択
6. 「build」ボタンを押すと、選択したパーツからコンピュータを組み立てます。
7. 組み立てられたコンピュータの評価を確認

## 使用時の注意事項

各パーツは上から順に選択する必要があります。

例) CPU 選択時
モデルを先に選択しようとすると選択項目が空になっています。

各パーツの情報は上の情報に当てはまるものを次の選択肢に含めています。

上から順番に入力しても次の選択肢が表示されないことがあります。

これはそれに当てはまる項目が単純に存在していないだけなので、一つ前の選択肢を別のものに変更してみてください。

## 各パーツの説明

#### CPU

中央演算装置（central processing unit）は、制御装置と演算装置から構成されています。

制御装置はデコーダとも呼ばれ、命令を解読し、他の周辺機器を制御します。演算装置は、加算機を含む、実際の計算を行う部分です。

<img src="https://github.com/daxchx/computer-builder/assets/149696768/e10ebbd2-e220-4181-91f9-6e330bf97942" width="400" height="auto" />

#### GPU

#### RAM

主記憶装置（主記憶装置）は、コンピュータシステムにおいて、CPU が直接アクセスできる記憶装置です。この中には、RAM が含まれます。

RAM はコンピュータシステムのメインメモリとして使用される揮発性のメモリです。揮発性とは、電力が供給されないとデータを保持できない性質を指します。

コンピュータをシャットダウンまたは、再起動すると、RAM 内のデータは失われるため、この特性が強調されます。

#### HDD

#### SSD

## 評価の算出

組み立てたコンピュータが仕事用、ゲーム用として使用する際にどれだけ適しているかをスコアに表示します。

各パーツのモデルにはベンチマークというスコアが記載されています。

このスコアを用いて、算出されています。

仕事用のスコアの算出には、

- cpu ベンチマーク × 0.6
- gpu ベンチマーク × 0.25
- ram ベンチマーク × 0.1
- hdd ベンチマーク × 0.025
  を合計した数値を用います。


***


## 技術スタック

stack.jpg

<table>
  <tr>
    <th>分類</th>
    <th>スタック名</th>
  </tr>
  <tr>
    <td>言語</td>
    <td>TypeScript</td>
  </tr>
  </tr>
  <tr>
    <td>スタイル</td>
    <td>TailwindCSS</td>
  </tr>
  </tr>
  <tr>
    <td>ビルドツール</td>
    <td>Vite</td>
  </tr>
  </tr>
  <tr>
    <td>デプロイ</td>
    <td>Vercel</td>
  </tr>
  <tr>
    <td rowspan="2">その他</td>
    <td>Git</td>
  </tr>
  <tr>
    <td>GitHub</td>
  </tr>
</table>

## クラス図

## アクティビティ図

## ワイヤーフレーム

## こだわった点

#### APIを使用して各パーツの情報を取得

フェッチ API は、リクエストやレスポンスといったプロトコルを操作する要素にアクセスするための JavaScript インターフェイスです。グローバルの fetch() メソッドも提供しており、簡単で論理的な方法で、非同期にネットワーク越しでリソースを取得することができます。

コールバックベースの API である XMLHttpRequest とは異なり、Fetch は Promise ベースであり、サービスワーカー で簡単に使用できる優れた代替手段を提供します。Fetch は、CORS やその他の HTTP 拡張機能などの高度な HTTP 概念も統合します。

基本的なフェッチリクエストは、以下のコードを見てください。

例) cpuのデータ取得
```
const cpuData = fetch(url)
  .then(response => response.json())
  .then((data) => {
    console.log(data)
  })
```

これはネットワーク越しに JSON ファイルを取得してパースし、コンソールにデータを出力するスクリプトです。 fetch() の最も簡単な使い方は 1 つの引数 — fetch で取得したいリソースへのパス — のみをとり、 Response オブジェクトで解決するプロミスを返します。

Response は、実際の JSON レスポンス本体を直接持っているのではなく、 HTTP レスポンス全体を表現するものです。 Response オブジェクトから JSON の本体の内容を抽出するには、 json() メソッドを使用します。これはレスポンス本体のテキストを JSON として解釈した結果で解決する第 2 のプロミスを返します。

#### MVC アーキテクチャ

互いのコンピュータオブジェクトがviewに直接干渉しないように設定しています。

#### UI

各パーツの選択がスムーズに行えるようにセレクトボタンのサイズを大きく設定しました。

また、組み立てたコンピュータの比較が簡単にできるように横スクロールを用いました。
これにより、簡単に性能の比較ができるようになりました。

この横スクロールは、下記のコードで実現しています。

TailwindCSS
```
<div class="overflow-x-scroll">
  <div></div> // 組み立てたコンピュータのelement
</div>
```

#### TypeScript interfaceの拡張

コンピュータが持っているデータはCPU, GPU, RAMは同一の型ですが、Storageのみtypeというデータが一つ多くなっています。

CPU, GPU, RAM
```
brand: brandName
model: modelName
```

Storage
```
type: storageType
brand: brandName
model: modelName
```

そこで、Partsという継承元の方を作成して
各パーツでPartsの型を継承しました。

パーツ
```
interface Parts {
  brand: string
  model: string
}

interface Storage extends Parts {
  type: string
}
```

これにより、型の指定がうまくできました。
データを安全に操作することができました。

オブジェクト指向プログラミング



## 参考文献

- https://developer.mozilla.org/ja/docs/Web/API/Fetch_API/Using_Fetch

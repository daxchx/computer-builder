
# Computer Builder

thumbnail.gif

## 説明

このアプリケーションではパーツを選んで「仮想のコンピュータ」を組み立て、その性能を評価し、比較することが可能です。

コンピュータを構成するパーツは全部で4種類。
- cpu
- gpu
- memory
- storage

各パーツの選択時には、ブランド、モデル、ストレージなどを入力します。
ブランドにはそのブランドが持っている情報をソートしてモデルに表示します。

## 使い方

1. URL にアクセス
2. CPU のブランドとモデルを選択
3. GPU のブランドとモデルを選択
4. Memory Card の数とブランドとモデルを選択
5. Storage のタイプとストレージとブランドとモデルを選択
6. 「build」ボタンを押すと、選択したパーツからコンピュータを組み立てます。
7. 組み立てられたコンピュータの評価を確認

## 使用時の注意事項

各パーツは上から順に選択する必要があります。

例) CPU 選択時
モデルを先に選択しようとすると選択項目が空になっています。

各パーツの情報は上の情報に当てはまるものを次の選択肢に含めています。

上から順番に入力しても次の選択肢が表示されないことがあります。

これはそれに当てはまる項目が単純に存在していないだけなので、一つ前の選択肢を別のものに変更してみてください。

## 各パーツの説明

### CPU（中央処理装置）

CPU（Central Processing Unit）は、コンピュータ内で計算や制御を担当する主要な部品です。

主にアルゴリズムに基づいて命令を実行し、データ処理を行います。クロックと呼ばれる振動に基づいて、定期的に命令を処理し、演算や論理操作を実行します。

また、キャッシュメモリを備え、高速なデータアクセスを可能にします。コンピュータの性能や速度は、CPUの性能に大きく依存しています。

### GPU（グラフィックス処理装置）

GPU（Graphics Processing Unit）は、主に画像処理やグラフィックス関連の演算に特化したプロセッシングユニットです。

最初はグラフィックス処理のために設計されましたが、近年では一般の計算処理（GPGPU：General-Purpose computing on Graphics Processing Units）にも利用され、高度な並列処理能力を持つことが特徴です。

特に、3Dグラフィックスや科学技術計算、機械学習などの分野で活用されています。

GPUは、CPUとは異なるアーキテクチャを持ち、大量のデータを同時に処理することが得意です。

### メモリ（RAM）

RAM（Random Access Memory）は、コンピュータがプログラムやデータにアクセスするための一時的な記憶装置です。

RAMは高速で読み書きが可能であり、コンピュータが実行中のプログラムや作業中のデータを一時的に格納します。

異なる種類のデータやプログラムがRAMに格納され、CPUがこれに迅速にアクセスして処理を行います。

しかし、RAMは電源を切るとデータが消失する揮発性のメモリであり、永続的なデータ保存には他のメディア（ハードディスクやSSDなど）が利用されます。

### ストレージ（HDD / SSD）

ストレージは、データや情報を永続的に保存するための装置やメディアのことを指します。

主にハードディスクドライブ（HDD）、ソリッドステートドライブ（SSD）、光学ディスク（CD、DVD、Blu-rayなど）、フラッシュドライブなどが一般的なストレージメディアとして使用されます。

コンピュータやデバイスのオペレーティングシステム、アプリケーション、ユーザーデータなどがストレージに保存され、電源を切ってもデータが保持される非揮発性メモリとして機能します。

#### HDD（ハードディスクドライブ）

HDD（Hard Disk Drive）は、データを永続的に保存するための記憶装置の一種です。

HDDは磁気ディスクを使用し、データは円盤上に磁気的なパターンとして記録されます。

読み取り/書き込みヘッドがディスク上を移動してデータアクセスを行います。

HDDは比較的大容量で、経済的なメモリソリューションとして普及していますが、動作部品が機械的であるため、SSDに比べて速度がやや低い傾向があります。

#### SSD（ソリッドステートドライブ）

SSD（Solid State Drive）は、データを永続的に保存するための記憶装置の一種で、フラッシュメモリを使用しています。

SSDは機械的な動作部品を持たず、情報を電子的に読み書きします。

このため、HDDよりも高速で信頼性があり、データアクセスが迅速です。

SSDは一般的に軽量・省電力で、コンピュータやデバイスの動作を向上させるために広く使用されています。

## 評価の算出

ユーザーがすべてのパーツを選んだら、プログラムは構築した仮想のコンピュータのスコアを計算します。
スコアは各パーツの性能に基づいており、ゲーム用か仕事用かによって重みが異なります。

これらのスコアは、ゲーミングまたは作業用の基準に従って、CPU,GPU,RAM,Storageの性能に重み付けされます。

例えば、ゲーミング用の基準では、
<table>
  <tr>
    <th>パーツ</th>
    <th>重み</th>
  </tr>
  <tr>
    <td>CPU</td>
    <td>25%</td>
  </tr>
  <tr>
    <td>GPU</td>
    <td>60%</td>
  </tr>
  <tr>
    <td>RAM</td>
    <td>12.5%</td>
  </tr>
  <tr>
    <td>Storage</td>
    <td>2.5%</td>
  </tr>
</table>


各パーツのスコア（Benchmark）は0~100が基本ですが、そのパーツが特別に優れている場合には100を超えることがあります。

特にSSDのベンチマークスコアは最大400%まで上がるので、最終的なスコアに上記の重みよりも大きな影響を与える可能性があります。

組み立てたコンピュータが仕事用、ゲーム用として使用する際にどれだけ適しているかをスコアに表示します。

各パーツのモデルにはベンチマークというスコアが記載されています。

このスコアを用いて、算出されています。

仕事用のスコアの算出には、

- cpu ベンチマーク × 0.6
- gpu ベンチマーク × 0.25
- ram ベンチマーク × 0.1
- hdd ベンチマーク × 0.025
  を合計した数値を用います。


***


## 技術スタック

stack.jpg

<table>
  <tr>
    <th>分類</th>
    <th>スタック名</th>
  </tr>
  <tr>
    <td>言語</td>
    <td>TypeScript</td>
  </tr>
  </tr>
  <tr>
    <td>スタイル</td>
    <td>TailwindCSS</td>
  </tr>
  </tr>
  <tr>
    <td>ビルドツール</td>
    <td>Vite</td>
  </tr>
  </tr>
  <tr>
    <td>デプロイ</td>
    <td>Vercel</td>
  </tr>
  <tr>
    <td rowspan="2">その他</td>
    <td>Git</td>
  </tr>
  <tr>
    <td>GitHub</td>
  </tr>
</table>

## クラス図

## アクティビティ図

## ワイヤーフレーム

## こだわった点

#### APIを使用して各パーツの情報を取得

フェッチ API は、リクエストやレスポンスといったプロトコルを操作する要素にアクセスするための JavaScript インターフェイスです。グローバルの fetch() メソッドも提供しており、簡単で論理的な方法で、非同期にネットワーク越しでリソースを取得することができます。

コールバックベースの API である XMLHttpRequest とは異なり、Fetch は Promise ベースであり、サービスワーカー で簡単に使用できる優れた代替手段を提供します。Fetch は、CORS やその他の HTTP 拡張機能などの高度な HTTP 概念も統合します。

基本的なフェッチリクエストは、以下のコードを見てください。

例) cpuのデータ取得
```
const cpuData = fetch(url)
  .then(response => response.json())
  .then((data) => {
    console.log(data)
  })
```

これはネットワーク越しに JSON ファイルを取得してパースし、コンソールにデータを出力するスクリプトです。 fetch() の最も簡単な使い方は 1 つの引数 — fetch で取得したいリソースへのパス — のみをとり、 Response オブジェクトで解決するプロミスを返します。

Response は、実際の JSON レスポンス本体を直接持っているのではなく、 HTTP レスポンス全体を表現するものです。 Response オブジェクトから JSON の本体の内容を抽出するには、 json() メソッドを使用します。これはレスポンス本体のテキストを JSON として解釈した結果で解決する第 2 のプロミスを返します。

#### MVC アーキテクチャ

互いのコンピュータオブジェクトがviewに直接干渉しないように設定しています。

#### UI

各パーツの選択がスムーズに行えるようにセレクトボタンのサイズを大きく設定しました。

また、組み立てたコンピュータの比較が簡単にできるように横スクロールを用いました。
これにより、簡単に性能の比較ができるようになりました。

この横スクロールは、下記のコードで実現しています。

TailwindCSS
```
<div class="overflow-x-scroll">
  <div></div> // 組み立てたコンピュータのelement
</div>
```

#### TypeScript interfaceの拡張

コンピュータが持っているデータはCPU, GPU, RAMは同一の型ですが、Storageのみtypeというデータが一つ多くなっています。

CPU, GPU, RAM
```
brand: brandName
model: modelName
```

Storage
```
type: storageType
brand: brandName
model: modelName
```

そこで、Partsという継承元の方を作成して
各パーツでPartsの型を継承しました。

パーツ
```
interface Parts {
  brand: string
  model: string
}

interface Storage extends Parts {
  type: string
}
```

これにより、型の指定がうまくできました。
データを安全に操作することができました。

オブジェクト指向プログラミング



## 参考文献

- https://developer.mozilla.org/ja/docs/Web/API/Fetch_API/Using_Fetch
